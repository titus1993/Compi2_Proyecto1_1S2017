
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Mar 20 23:49:47 CST 2017
//----------------------------------------------------

package Analisis.Haskell;

import Constante.Constante;
import Funciones_Haskell.*;
import Ejecucion_Haskell.*;
import java_cup.runtime.Symbol;
import Interface.TitusNotificaciones;
import java.util.ArrayList;
import Ejecucion_Haskell.Ambito;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Mon Mar 20 23:49:47 CST 2017
  */
public class Haskell_Sintactico extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public Haskell_Sintactico() {super();}

  /** Constructor which sets the default scanner. */
  public Haskell_Sintactico(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Haskell_Sintactico(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\107\000\002\002\004\000\002\002\003\000\002\003" +
    "\004\000\002\003\003\000\002\004\007\000\002\004\006" +
    "\000\002\005\005\000\002\005\003\000\002\006\003\000" +
    "\002\007\004\000\002\007\003\000\002\010\003\000\002" +
    "\010\003\000\002\010\003\000\002\010\003\000\002\014" +
    "\006\000\002\011\011\000\002\023\006\000\002\024\004" +
    "\000\002\024\003\000\002\025\006\000\002\026\003\000" +
    "\002\026\003\000\002\030\005\000\002\030\005\000\002" +
    "\030\003\000\002\031\005\000\002\031\005\000\002\031" +
    "\005\000\002\031\005\000\002\031\005\000\002\031\005" +
    "\000\002\031\003\000\002\012\005\000\002\012\005\000" +
    "\002\012\005\000\002\012\005\000\002\012\005\000\002" +
    "\012\005\000\002\012\005\000\002\012\004\000\002\012" +
    "\003\000\002\012\003\000\002\012\003\000\002\012\005" +
    "\000\002\012\003\000\002\012\003\000\002\012\003\000" +
    "\002\012\005\000\002\012\005\000\002\013\005\000\002" +
    "\017\003\000\002\017\003\000\002\027\006\000\002\027" +
    "\005\000\002\022\004\000\002\022\004\000\002\022\004" +
    "\000\002\022\004\000\002\022\004\000\002\022\004\000" +
    "\002\022\004\000\002\022\004\000\002\022\004\000\002" +
    "\022\004\000\002\022\004\000\002\022\004\000\002\022" +
    "\004\000\002\015\005\000\002\016\005\000\002\016\003" +
    "" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\210\000\004\004\004\001\002\000\006\004\012\032" +
    "\014\001\002\000\006\002\000\004\004\001\002\000\006" +
    "\002\ufffe\004\ufffe\001\002\000\004\002\010\001\002\000" +
    "\004\002\001\001\002\000\006\002\uffff\004\uffff\001\002" +
    "\000\006\032\ufffa\064\ufffa\001\002\000\006\032\207\064" +
    "\206\001\002\000\030\004\033\005\017\006\034\007\030" +
    "\011\036\017\042\020\016\033\035\035\026\056\020\061" +
    "\025\001\002\000\110\004\uffd3\005\uffd3\006\uffd3\007\uffd3" +
    "\010\uffd3\011\uffd3\012\uffd3\013\uffd3\014\uffd3\015\uffd3\016" +
    "\uffd3\017\uffd3\020\uffd3\021\uffd3\022\uffd3\023\uffd3\024\uffd3" +
    "\025\uffd3\026\uffd3\027\uffd3\030\uffd3\031\uffd3\033\uffd3\034" +
    "\uffd3\035\uffd3\053\uffd3\054\uffd3\055\uffd3\056\uffd3\057\uffd3" +
    "\060\uffd3\061\uffd3\063\uffd3\064\uffd3\065\uffd3\001\002\000" +
    "\022\004\033\005\017\006\034\007\030\011\036\017\042" +
    "\020\016\033\035\001\002\000\110\004\uffd8\005\uffd8\006" +
    "\uffd8\007\uffd8\010\uffd8\011\uffd8\012\uffd8\013\uffd8\014\uffd8" +
    "\015\uffd8\016\uffd8\017\uffd8\020\uffd8\021\uffd8\022\uffd8\023" +
    "\uffd8\024\uffd8\025\uffd8\026\uffd8\027\uffd8\030\uffd8\031\uffd8" +
    "\033\uffd8\034\uffd8\035\uffd8\053\uffd8\054\uffd8\055\uffd8\056" +
    "\uffd8\057\uffd8\060\uffd8\061\uffd8\063\uffd8\064\uffd8\065\uffd8" +
    "\001\002\000\022\004\033\005\017\006\034\007\030\011" +
    "\036\017\042\020\016\033\035\001\002\000\004\055\175" +
    "\001\002\000\036\004\ufff7\005\ufff7\006\ufff7\007\ufff7\011" +
    "\ufff7\017\ufff7\020\ufff7\033\ufff7\035\ufff7\055\ufff7\056\ufff7" +
    "\060\ufff7\061\ufff7\065\ufff7\001\002\000\036\004\ufff6\005" +
    "\ufff6\006\ufff6\007\ufff6\011\ufff6\017\ufff6\020\ufff6\033\ufff6" +
    "\035\ufff6\055\ufff6\056\ufff6\060\ufff6\061\ufff6\065\ufff6\001" +
    "\002\000\110\004\uffe1\005\uffe1\006\uffe1\007\uffe1\010\122" +
    "\011\121\012\126\013\125\014\123\015\120\016\124\017" +
    "\uffe1\020\uffe1\021\uffe1\022\uffe1\023\uffe1\024\uffe1\025\uffe1" +
    "\026\uffe1\027\uffe1\030\uffe1\031\uffe1\033\uffe1\034\uffe1\035" +
    "\uffe1\053\127\054\117\055\uffe1\056\uffe1\057\uffe1\060\uffe1" +
    "\061\uffe1\063\uffe1\064\uffe1\065\uffe1\001\002\000\022\004" +
    "\033\005\017\006\034\007\030\011\036\017\042\020\016" +
    "\033\035\001\002\000\004\004\157\001\002\000\070\004" +
    "\uffe8\005\uffe8\006\uffe8\007\uffe8\011\uffe8\017\uffe8\020\uffe8" +
    "\021\uffe8\022\147\023\146\024\143\025\144\026\145\027" +
    "\150\030\uffe8\031\uffe8\033\uffe8\034\uffe8\035\uffe8\055\uffe8" +
    "\056\uffe8\057\uffe8\060\uffe8\061\uffe8\063\uffe8\064\uffe8\065" +
    "\uffe8\001\002\000\110\004\uffd4\005\uffd4\006\uffd4\007\uffd4" +
    "\010\uffd4\011\uffd4\012\uffd4\013\uffd4\014\uffd4\015\uffd4\016" +
    "\uffd4\017\uffd4\020\uffd4\021\uffd4\022\uffd4\023\uffd4\024\uffd4" +
    "\025\uffd4\026\uffd4\027\uffd4\030\uffd4\031\uffd4\033\uffd4\034" +
    "\uffd4\035\uffd4\053\uffd4\054\uffd4\055\uffd4\056\uffd4\057\uffd4" +
    "\060\uffd4\061\uffd4\063\uffd4\064\uffd4\065\uffd4\001\002\000" +
    "\036\004\ufff3\005\ufff3\006\ufff3\007\ufff3\011\ufff3\017\ufff3" +
    "\020\ufff3\033\ufff3\035\ufff3\055\ufff3\056\ufff3\060\ufff3\061" +
    "\ufff3\065\ufff3\001\002\000\110\004\uffd6\005\uffd6\006\uffd6" +
    "\007\uffd6\010\uffd6\011\uffd6\012\uffd6\013\uffd6\014\uffd6\015" +
    "\uffd6\016\uffd6\017\uffd6\020\uffd6\021\uffd6\022\uffd6\023\uffd6" +
    "\024\uffd6\025\uffd6\026\uffd6\027\uffd6\030\uffd6\031\uffd6\033" +
    "\uffd6\034\uffd6\035\uffd6\053\uffd6\054\uffd6\055\uffd6\056\uffd6" +
    "\057\uffd6\060\uffd6\061\uffd6\063\uffd6\064\uffd6\065\uffd6\001" +
    "\002\000\110\004\uffd7\005\uffd7\006\uffd7\007\uffd7\010\uffd7" +
    "\011\uffd7\012\uffd7\013\uffd7\014\uffd7\015\uffd7\016\uffd7\017" +
    "\uffd7\020\uffd7\021\uffd7\022\uffd7\023\uffd7\024\uffd7\025\uffd7" +
    "\026\uffd7\027\uffd7\030\uffd7\031\uffd7\033\uffd7\034\uffd7\035" +
    "\uffd7\053\uffd7\054\uffd7\055\uffd7\056\uffd7\057\uffd7\060\uffd7" +
    "\061\uffd7\063\uffd7\064\uffd7\065\uffd7\001\002\000\110\004" +
    "\uffd2\005\uffd2\006\uffd2\007\uffd2\010\uffd2\011\uffd2\012\uffd2" +
    "\013\uffd2\014\uffd2\015\uffd2\016\uffd2\017\uffd2\020\uffd2\021" +
    "\uffd2\022\uffd2\023\uffd2\024\uffd2\025\uffd2\026\uffd2\027\uffd2" +
    "\030\uffd2\031\uffd2\033\uffd2\034\uffd2\035\uffd2\053\uffd2\054" +
    "\uffd2\055\uffd2\056\uffd2\057\uffd2\060\uffd2\061\uffd2\063\uffd2" +
    "\064\uffd2\065\uffd2\001\002\000\022\004\033\005\017\006" +
    "\034\007\030\011\036\017\042\020\016\033\035\001\002" +
    "\000\022\004\033\005\017\006\034\007\030\011\036\017" +
    "\042\020\016\033\035\001\002\000\036\004\ufff5\005\ufff5" +
    "\006\ufff5\007\ufff5\011\ufff5\017\ufff5\020\ufff5\033\ufff5\035" +
    "\ufff5\055\ufff5\056\ufff5\060\ufff5\061\ufff5\065\ufff5\001\002" +
    "\000\036\004\033\005\017\006\034\007\030\011\036\017" +
    "\042\020\016\033\035\035\026\055\ufff9\056\020\060\ufff9" +
    "\061\025\065\ufff9\001\002\000\042\004\ufff4\005\ufff4\006" +
    "\ufff4\007\ufff4\011\ufff4\017\ufff4\020\ufff4\030\065\031\066" +
    "\033\ufff4\035\ufff4\055\ufff4\056\ufff4\060\ufff4\061\ufff4\065" +
    "\ufff4\001\002\000\036\004\045\036\057\037\054\040\043" +
    "\041\051\042\061\043\053\044\047\045\046\046\050\047" +
    "\055\050\063\051\052\052\060\001\002\000\022\004\033" +
    "\005\017\006\034\007\030\011\036\017\042\020\016\033" +
    "\035\001\002\000\004\017\uffcd\001\002\000\004\062\105" +
    "\001\002\000\022\004\033\005\017\006\034\007\030\011" +
    "\036\017\042\020\016\033\035\001\002\000\022\004\033" +
    "\005\017\006\034\007\030\011\036\017\042\020\016\033" +
    "\035\001\002\000\022\004\033\005\017\006\034\007\030" +
    "\011\036\017\042\020\016\033\035\001\002\000\022\004" +
    "\033\005\017\006\034\007\030\011\036\017\042\020\016" +
    "\033\035\001\002\000\022\004\033\005\017\006\034\007" +
    "\030\011\036\017\042\020\016\033\035\001\002\000\022" +
    "\004\033\005\017\006\034\007\030\011\036\017\042\020" +
    "\016\033\035\001\002\000\022\004\033\005\017\006\034" +
    "\007\030\011\036\017\042\020\016\033\035\001\002\000" +
    "\022\004\033\005\017\006\034\007\030\011\036\017\042" +
    "\020\016\033\035\001\002\000\004\017\uffce\001\002\000" +
    "\022\004\033\005\017\006\034\007\030\011\036\017\042" +
    "\020\016\033\035\001\002\000\022\004\033\005\017\006" +
    "\034\007\030\011\036\017\042\020\016\033\035\001\002" +
    "\000\022\004\033\005\017\006\034\007\030\011\036\017" +
    "\042\020\016\033\035\001\002\000\004\017\071\001\002" +
    "\000\022\004\033\005\017\006\034\007\030\011\036\017" +
    "\042\020\016\033\035\001\002\000\010\017\uffc5\030\065" +
    "\031\066\001\002\000\022\004\033\005\017\006\034\007" +
    "\030\011\036\017\042\020\016\033\035\001\002\000\022" +
    "\004\033\005\017\006\034\007\030\011\036\017\042\020" +
    "\016\033\035\001\002\000\054\004\uffe9\005\uffe9\006\uffe9" +
    "\007\uffe9\011\uffe9\017\uffe9\020\uffe9\021\uffe9\030\uffe9\031" +
    "\uffe9\033\uffe9\034\uffe9\035\uffe9\055\uffe9\056\uffe9\057\uffe9" +
    "\060\uffe9\061\uffe9\063\uffe9\064\uffe9\065\uffe9\001\002\000" +
    "\054\004\uffea\005\uffea\006\uffea\007\uffea\011\uffea\017\uffea" +
    "\020\uffea\021\uffea\030\uffea\031\uffea\033\uffea\034\uffea\035" +
    "\uffea\055\uffea\056\uffea\057\uffea\060\uffea\061\uffea\063\uffea" +
    "\064\uffea\065\uffea\001\002\000\110\004\uffcf\005\uffcf\006" +
    "\uffcf\007\uffcf\010\uffcf\011\uffcf\012\uffcf\013\uffcf\014\uffcf" +
    "\015\uffcf\016\uffcf\017\uffcf\020\uffcf\021\uffcf\022\uffcf\023" +
    "\uffcf\024\uffcf\025\uffcf\026\uffcf\027\uffcf\030\uffcf\031\uffcf" +
    "\033\uffcf\034\uffcf\035\uffcf\053\uffcf\054\uffcf\055\uffcf\056" +
    "\uffcf\057\uffcf\060\uffcf\061\uffcf\063\uffcf\064\uffcf\065\uffcf" +
    "\001\002\000\010\017\uffc0\030\065\031\066\001\002\000" +
    "\010\017\uffc3\030\065\031\066\001\002\000\010\017\uffbe" +
    "\030\065\031\066\001\002\000\010\017\uffc6\030\065\031" +
    "\066\001\002\000\010\017\uffc1\030\065\031\066\001\002" +
    "\000\010\017\uffca\030\065\031\066\001\002\000\010\017" +
    "\uffc4\030\065\031\066\001\002\000\010\017\uffbf\030\065" +
    "\031\066\001\002\000\010\017\uffc7\030\065\031\066\001" +
    "\002\000\010\017\uffc9\030\065\031\066\001\002\000\010" +
    "\017\uffc8\030\065\031\066\001\002\000\024\004\033\005" +
    "\017\006\034\007\030\011\036\017\042\020\016\033\035" +
    "\063\107\001\002\000\014\030\065\031\066\034\uffbb\063" +
    "\uffbb\064\uffbb\001\002\000\004\017\uffcb\001\002\000\006" +
    "\063\112\064\111\001\002\000\022\004\033\005\017\006" +
    "\034\007\030\011\036\017\042\020\016\033\035\001\002" +
    "\000\004\017\uffcc\001\002\000\014\030\065\031\066\034" +
    "\uffbc\063\uffbc\064\uffbc\001\002\000\010\017\uffc2\030\065" +
    "\031\066\001\002\000\036\004\ufff8\005\ufff8\006\ufff8\007" +
    "\ufff8\011\ufff8\017\ufff8\020\ufff8\033\ufff8\035\ufff8\055\ufff8" +
    "\056\ufff8\060\ufff8\061\ufff8\065\ufff8\001\002\000\110\004" +
    "\uffd9\005\uffd9\006\uffd9\007\uffd9\010\uffd9\011\uffd9\012\126" +
    "\013\125\014\123\015\120\016\124\017\uffd9\020\uffd9\021" +
    "\uffd9\022\uffd9\023\uffd9\024\uffd9\025\uffd9\026\uffd9\027\uffd9" +
    "\030\uffd9\031\uffd9\033\uffd9\034\uffd9\035\uffd9\053\uffd9\054" +
    "\uffd9\055\uffd9\056\uffd9\057\uffd9\060\uffd9\061\uffd9\063\uffd9" +
    "\064\uffd9\065\uffd9\001\002\000\022\004\033\005\017\006" +
    "\034\007\030\011\036\017\042\020\016\033\035\001\002" +
    "\000\022\004\033\005\017\006\034\007\030\011\036\017" +
    "\042\020\016\033\035\001\002\000\022\004\033\005\017" +
    "\006\034\007\030\011\036\017\042\020\016\033\035\001" +
    "\002\000\022\004\033\005\017\006\034\007\030\011\036" +
    "\017\042\020\016\033\035\001\002\000\022\004\033\005" +
    "\017\006\034\007\030\011\036\017\042\020\016\033\035" +
    "\001\002\000\022\004\033\005\017\006\034\007\030\011" +
    "\036\017\042\020\016\033\035\001\002\000\022\004\033" +
    "\005\017\006\034\007\030\011\036\017\042\020\016\033" +
    "\035\001\002\000\022\004\033\005\017\006\034\007\030" +
    "\011\036\017\042\020\016\033\035\001\002\000\022\004" +
    "\033\005\017\006\034\007\030\011\036\017\042\020\016" +
    "\033\035\001\002\000\110\004\uffd1\005\uffd1\006\uffd1\007" +
    "\uffd1\010\122\011\121\012\126\013\125\014\123\015\120" +
    "\016\124\017\uffd1\020\uffd1\021\uffd1\022\uffd1\023\uffd1\024" +
    "\uffd1\025\uffd1\026\uffd1\027\uffd1\030\uffd1\031\uffd1\033\uffd1" +
    "\034\uffd1\035\uffd1\053\uffd1\054\uffd1\055\uffd1\056\uffd1\057" +
    "\uffd1\060\uffd1\061\uffd1\063\uffd1\064\uffd1\065\uffd1\001\002" +
    "\000\110\004\uffde\005\uffde\006\uffde\007\uffde\010\uffde\011" +
    "\uffde\012\uffde\013\uffde\014\uffde\015\120\016\124\017\uffde" +
    "\020\uffde\021\uffde\022\uffde\023\uffde\024\uffde\025\uffde\026" +
    "\uffde\027\uffde\030\uffde\031\uffde\033\uffde\034\uffde\035\uffde" +
    "\053\uffde\054\uffde\055\uffde\056\uffde\057\uffde\060\uffde\061" +
    "\uffde\063\uffde\064\uffde\065\uffde\001\002\000\110\004\uffdd" +
    "\005\uffdd\006\uffdd\007\uffdd\010\uffdd\011\uffdd\012\uffdd\013" +
    "\uffdd\014\uffdd\015\120\016\124\017\uffdd\020\uffdd\021\uffdd" +
    "\022\uffdd\023\uffdd\024\uffdd\025\uffdd\026\uffdd\027\uffdd\030" +
    "\uffdd\031\uffdd\033\uffdd\034\uffdd\035\uffdd\053\uffdd\054\uffdd" +
    "\055\uffdd\056\uffdd\057\uffdd\060\uffdd\061\uffdd\063\uffdd\064" +
    "\uffdd\065\uffdd\001\002\000\110\004\uffda\005\uffda\006\uffda" +
    "\007\uffda\010\uffda\011\uffda\012\uffda\013\uffda\014\uffda\015" +
    "\120\016\124\017\uffda\020\uffda\021\uffda\022\uffda\023\uffda" +
    "\024\uffda\025\uffda\026\uffda\027\uffda\030\uffda\031\uffda\033" +
    "\uffda\034\uffda\035\uffda\053\uffda\054\uffda\055\uffda\056\uffda" +
    "\057\uffda\060\uffda\061\uffda\063\uffda\064\uffda\065\uffda\001" +
    "\002\000\110\004\uffdc\005\uffdc\006\uffdc\007\uffdc\010\uffdc" +
    "\011\uffdc\012\uffdc\013\uffdc\014\uffdc\015\120\016\124\017" +
    "\uffdc\020\uffdc\021\uffdc\022\uffdc\023\uffdc\024\uffdc\025\uffdc" +
    "\026\uffdc\027\uffdc\030\uffdc\031\uffdc\033\uffdc\034\uffdc\035" +
    "\uffdc\053\uffdc\054\uffdc\055\uffdc\056\uffdc\057\uffdc\060\uffdc" +
    "\061\uffdc\063\uffdc\064\uffdc\065\uffdc\001\002\000\110\004" +
    "\uffe0\005\uffe0\006\uffe0\007\uffe0\010\uffe0\011\uffe0\012\126" +
    "\013\125\014\123\015\120\016\124\017\uffe0\020\uffe0\021" +
    "\uffe0\022\uffe0\023\uffe0\024\uffe0\025\uffe0\026\uffe0\027\uffe0" +
    "\030\uffe0\031\uffe0\033\uffe0\034\uffe0\035\uffe0\053\uffe0\054" +
    "\uffe0\055\uffe0\056\uffe0\057\uffe0\060\uffe0\061\uffe0\063\uffe0" +
    "\064\uffe0\065\uffe0\001\002\000\110\004\uffdf\005\uffdf\006" +
    "\uffdf\007\uffdf\010\uffdf\011\uffdf\012\126\013\125\014\123" +
    "\015\120\016\124\017\uffdf\020\uffdf\021\uffdf\022\uffdf\023" +
    "\uffdf\024\uffdf\025\uffdf\026\uffdf\027\uffdf\030\uffdf\031\uffdf" +
    "\033\uffdf\034\uffdf\035\uffdf\053\uffdf\054\uffdf\055\uffdf\056" +
    "\uffdf\057\uffdf\060\uffdf\061\uffdf\063\uffdf\064\uffdf\065\uffdf" +
    "\001\002\000\110\004\uffdb\005\uffdb\006\uffdb\007\uffdb\010" +
    "\uffdb\011\uffdb\012\uffdb\013\uffdb\014\uffdb\015\120\016\124" +
    "\017\uffdb\020\uffdb\021\uffdb\022\uffdb\023\uffdb\024\uffdb\025" +
    "\uffdb\026\uffdb\027\uffdb\030\uffdb\031\uffdb\033\uffdb\034\uffdb" +
    "\035\uffdb\053\uffdb\054\uffdb\055\uffdb\056\uffdb\057\uffdb\060" +
    "\uffdb\061\uffdb\063\uffdb\064\uffdb\065\uffdb\001\002\000\110" +
    "\004\uffd0\005\uffd0\006\uffd0\007\uffd0\010\122\011\121\012" +
    "\126\013\125\014\123\015\120\016\124\017\uffd0\020\uffd0" +
    "\021\uffd0\022\uffd0\023\uffd0\024\uffd0\025\uffd0\026\uffd0\027" +
    "\uffd0\030\uffd0\031\uffd0\033\uffd0\034\uffd0\035\uffd0\053\127" +
    "\054\uffd0\055\uffd0\056\uffd0\057\uffd0\060\uffd0\061\uffd0\063" +
    "\uffd0\064\uffd0\065\uffd0\001\002\000\006\034\142\064\111" +
    "\001\002\000\110\004\uffbd\005\uffbd\006\uffbd\007\uffbd\010" +
    "\uffbd\011\uffbd\012\uffbd\013\uffbd\014\uffbd\015\uffbd\016\uffbd" +
    "\017\uffbd\020\uffbd\021\uffbd\022\uffbd\023\uffbd\024\uffbd\025" +
    "\uffbd\026\uffbd\027\uffbd\030\uffbd\031\uffbd\033\uffbd\034\uffbd" +
    "\035\uffbd\053\uffbd\054\uffbd\055\uffbd\056\uffbd\057\uffbd\060" +
    "\uffbd\061\uffbd\063\uffbd\064\uffbd\065\uffbd\001\002\000\022" +
    "\004\033\005\017\006\034\007\030\011\036\017\042\020" +
    "\016\033\035\001\002\000\022\004\033\005\017\006\034" +
    "\007\030\011\036\017\042\020\016\033\035\001\002\000" +
    "\022\004\033\005\017\006\034\007\030\011\036\017\042" +
    "\020\016\033\035\001\002\000\022\004\033\005\017\006" +
    "\034\007\030\011\036\017\042\020\016\033\035\001\002" +
    "\000\022\004\033\005\017\006\034\007\030\011\036\017" +
    "\042\020\016\033\035\001\002\000\022\004\033\005\017" +
    "\006\034\007\030\011\036\017\042\020\016\033\035\001" +
    "\002\000\070\004\uffe2\005\uffe2\006\uffe2\007\uffe2\011\uffe2" +
    "\017\uffe2\020\uffe2\021\uffe2\022\uffe2\023\uffe2\024\uffe2\025" +
    "\uffe2\026\uffe2\027\uffe2\030\uffe2\031\uffe2\033\uffe2\034\uffe2" +
    "\035\uffe2\055\uffe2\056\uffe2\057\uffe2\060\uffe2\061\uffe2\063" +
    "\uffe2\064\uffe2\065\uffe2\001\002\000\070\004\uffe7\005\uffe7" +
    "\006\uffe7\007\uffe7\011\uffe7\017\uffe7\020\uffe7\021\uffe7\022" +
    "\uffe7\023\uffe7\024\uffe7\025\uffe7\026\uffe7\027\uffe7\030\uffe7" +
    "\031\uffe7\033\uffe7\034\uffe7\035\uffe7\055\uffe7\056\uffe7\057" +
    "\uffe7\060\uffe7\061\uffe7\063\uffe7\064\uffe7\065\uffe7\001\002" +
    "\000\070\004\uffe6\005\uffe6\006\uffe6\007\uffe6\011\uffe6\017" +
    "\uffe6\020\uffe6\021\uffe6\022\uffe6\023\uffe6\024\uffe6\025\uffe6" +
    "\026\uffe6\027\uffe6\030\uffe6\031\uffe6\033\uffe6\034\uffe6\035" +
    "\uffe6\055\uffe6\056\uffe6\057\uffe6\060\uffe6\061\uffe6\063\uffe6" +
    "\064\uffe6\065\uffe6\001\002\000\070\004\uffe3\005\uffe3\006" +
    "\uffe3\007\uffe3\011\uffe3\017\uffe3\020\uffe3\021\uffe3\022\uffe3" +
    "\023\uffe3\024\uffe3\025\uffe3\026\uffe3\027\uffe3\030\uffe3\031" +
    "\uffe3\033\uffe3\034\uffe3\035\uffe3\055\uffe3\056\uffe3\057\uffe3" +
    "\060\uffe3\061\uffe3\063\uffe3\064\uffe3\065\uffe3\001\002\000" +
    "\070\004\uffe4\005\uffe4\006\uffe4\007\uffe4\011\uffe4\017\uffe4" +
    "\020\uffe4\021\uffe4\022\uffe4\023\uffe4\024\uffe4\025\uffe4\026" +
    "\uffe4\027\uffe4\030\uffe4\031\uffe4\033\uffe4\034\uffe4\035\uffe4" +
    "\055\uffe4\056\uffe4\057\uffe4\060\uffe4\061\uffe4\063\uffe4\064" +
    "\uffe4\065\uffe4\001\002\000\070\004\uffe5\005\uffe5\006\uffe5" +
    "\007\uffe5\011\uffe5\017\uffe5\020\uffe5\021\uffe5\022\uffe5\023" +
    "\uffe5\024\uffe5\025\uffe5\026\uffe5\027\uffe5\030\uffe5\031\uffe5" +
    "\033\uffe5\034\uffe5\035\uffe5\055\uffe5\056\uffe5\057\uffe5\060" +
    "\uffe5\061\uffe5\063\uffe5\064\uffe5\065\uffe5\001\002\000\004" +
    "\032\160\001\002\000\022\004\033\005\017\006\034\007" +
    "\030\011\036\017\042\020\016\033\035\001\002\000\042" +
    "\004\ufff2\005\ufff2\006\ufff2\007\ufff2\011\ufff2\017\ufff2\020" +
    "\ufff2\030\065\031\066\033\ufff2\035\ufff2\055\ufff2\056\ufff2" +
    "\060\ufff2\061\ufff2\065\ufff2\001\002\000\012\005\164\006" +
    "\165\030\065\031\066\001\002\000\010\005\164\006\165" +
    "\055\173\001\002\000\004\066\uffec\001\002\000\004\066" +
    "\uffeb\001\002\000\004\066\170\001\002\000\010\005\uffee" +
    "\006\uffee\055\uffee\001\002\000\030\004\033\005\017\006" +
    "\034\007\030\011\036\017\042\020\016\033\035\035\026" +
    "\056\020\061\025\001\002\000\004\065\172\001\002\000" +
    "\010\005\uffed\006\uffed\055\uffed\001\002\000\036\004\ufff0" +
    "\005\ufff0\006\ufff0\007\ufff0\011\ufff0\017\ufff0\020\ufff0\033" +
    "\ufff0\035\ufff0\055\ufff0\056\ufff0\060\ufff0\061\ufff0\065\ufff0" +
    "\001\002\000\010\005\uffef\006\uffef\055\uffef\001\002\000" +
    "\006\002\ufffc\004\ufffc\001\002\000\010\030\065\031\066" +
    "\057\177\001\002\000\030\004\033\005\017\006\034\007" +
    "\030\011\036\017\042\020\016\033\035\035\026\056\020" +
    "\061\025\001\002\000\004\060\201\001\002\000\030\004" +
    "\033\005\017\006\034\007\030\011\036\017\042\020\016" +
    "\033\035\035\026\056\020\061\025\001\002\000\004\055" +
    "\203\001\002\000\036\004\ufff1\005\ufff1\006\ufff1\007\ufff1" +
    "\011\ufff1\017\ufff1\020\ufff1\033\ufff1\035\ufff1\055\ufff1\056" +
    "\ufff1\060\ufff1\061\ufff1\065\ufff1\001\002\000\010\021\205" +
    "\030\065\031\066\001\002\000\110\004\uffd5\005\uffd5\006" +
    "\uffd5\007\uffd5\010\uffd5\011\uffd5\012\uffd5\013\uffd5\014\uffd5" +
    "\015\uffd5\016\uffd5\017\uffd5\020\uffd5\021\uffd5\022\uffd5\023" +
    "\uffd5\024\uffd5\025\uffd5\026\uffd5\027\uffd5\030\uffd5\031\uffd5" +
    "\033\uffd5\034\uffd5\035\uffd5\053\uffd5\054\uffd5\055\uffd5\056" +
    "\uffd5\057\uffd5\060\uffd5\061\uffd5\063\uffd5\064\uffd5\065\uffd5" +
    "\001\002\000\004\004\212\001\002\000\030\004\033\005" +
    "\017\006\034\007\030\011\036\017\042\020\016\033\035" +
    "\035\026\056\020\061\025\001\002\000\004\055\211\001" +
    "\002\000\006\002\ufffd\004\ufffd\001\002\000\006\032\ufffb" +
    "\064\ufffb\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\210\000\010\002\006\003\004\004\005\001\001\000" +
    "\004\005\012\001\001\000\004\004\010\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\030\006\020" +
    "\007\037\010\021\011\022\012\023\013\031\014\030\015" +
    "\014\023\036\030\040\031\026\001\001\000\002\001\001" +
    "\000\014\012\023\013\031\015\014\030\203\031\026\001" +
    "\001\000\002\001\001\000\014\012\023\013\031\015\014" +
    "\030\175\031\026\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\012\023" +
    "\013\031\015\014\030\161\031\026\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\016\012\023\013\031\015\014\016\140\030\105\031\026" +
    "\001\001\000\010\012\115\013\031\015\014\001\001\000" +
    "\002\001\001\000\024\010\114\011\022\012\023\013\031" +
    "\014\030\015\014\023\036\030\040\031\026\001\001\000" +
    "\002\001\001\000\010\017\061\022\055\027\043\001\001" +
    "\000\014\012\023\013\031\015\014\030\113\031\026\001" +
    "\001\000\002\001\001\000\002\001\001\000\014\012\023" +
    "\013\031\015\014\030\103\031\026\001\001\000\014\012" +
    "\023\013\031\015\014\030\102\031\026\001\001\000\014" +
    "\012\023\013\031\015\014\030\101\031\026\001\001\000" +
    "\014\012\023\013\031\015\014\030\100\031\026\001\001" +
    "\000\014\012\023\013\031\015\014\030\077\031\026\001" +
    "\001\000\014\012\023\013\031\015\014\030\076\031\026" +
    "\001\001\000\014\012\023\013\031\015\014\030\075\031" +
    "\026\001\001\000\014\012\023\013\031\015\014\030\074" +
    "\031\026\001\001\000\002\001\001\000\014\012\023\013" +
    "\031\015\014\030\073\031\026\001\001\000\014\012\023" +
    "\013\031\015\014\030\072\031\026\001\001\000\014\012" +
    "\023\013\031\015\014\030\071\031\026\001\001\000\002" +
    "\001\001\000\014\012\023\013\031\015\014\030\063\031" +
    "\026\001\001\000\002\001\001\000\014\012\023\013\031" +
    "\015\014\030\067\031\026\001\001\000\014\012\023\013" +
    "\031\015\014\030\066\031\026\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\016\012\023\013\031\015\014\016\107\030\105\031" +
    "\026\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\014\012\023\013\031\015\014\030\112\031" +
    "\026\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\012" +
    "\137\013\031\015\014\001\001\000\010\012\136\013\031" +
    "\015\014\001\001\000\010\012\135\013\031\015\014\001" +
    "\001\000\010\012\134\013\031\015\014\001\001\000\010" +
    "\012\133\013\031\015\014\001\001\000\010\012\132\013" +
    "\031\015\014\001\001\000\010\012\131\013\031\015\014" +
    "\001\001\000\010\012\130\013\031\015\014\001\001\000" +
    "\010\012\127\013\031\015\014\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\012\012\023\013\031\015\014\031\155\001\001" +
    "\000\012\012\023\013\031\015\014\031\154\001\001\000" +
    "\012\012\023\013\031\015\014\031\153\001\001\000\012" +
    "\012\023\013\031\015\014\031\152\001\001\000\012\012" +
    "\023\013\031\015\014\031\151\001\001\000\012\012\023" +
    "\013\031\015\014\031\150\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\014\012" +
    "\023\013\031\015\014\030\160\031\026\001\001\000\002" +
    "\001\001\000\010\024\162\025\166\026\165\001\001\000" +
    "\006\025\173\026\165\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\030\006" +
    "\170\007\037\010\021\011\022\012\023\013\031\014\030" +
    "\015\014\023\036\030\040\031\026\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\030\006\177\007" +
    "\037\010\021\011\022\012\023\013\031\014\030\015\014" +
    "\023\036\030\040\031\026\001\001\000\002\001\001\000" +
    "\030\006\201\007\037\010\021\011\022\012\023\013\031" +
    "\014\030\015\014\023\036\030\040\031\026\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\030\006\207\007\037\010" +
    "\021\011\022\012\023\013\031\014\030\015\014\023\036" +
    "\030\040\031\026\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$Haskell_Sintactico$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$Haskell_Sintactico$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$Haskell_Sintactico$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


//Codigo visible
    public Haskell_Ejecucion Ejecucion = null;

    public void syntax_error(Symbol s){
        TitusNotificaciones.InsertarError("Sintactico",s.value + " no reconocido", s.left, s.right);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        //System.out.println("Error sintactico en la LÃ­nea " + (s.left) +" Columna "+s.right+ ". Lexema "+s.value + " no reconocido." );
    }


}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$Haskell_Sintactico$actions {

//Codigo de acciones
      

  private final Haskell_Sintactico parser;

  /** Constructor */
  CUP$Haskell_Sintactico$actions(Haskell_Sintactico parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$Haskell_Sintactico$do_action(
    int                        CUP$Haskell_Sintactico$act_num,
    java_cup.runtime.lr_parser CUP$Haskell_Sintactico$parser,
    java.util.Stack            CUP$Haskell_Sintactico$stack,
    int                        CUP$Haskell_Sintactico$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$Haskell_Sintactico$result;

      /* select the action based on the action number */
      switch (CUP$Haskell_Sintactico$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // LISTA_EXP ::= LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                ArrayList<FNodoExpresion> lista = new ArrayList<>();
                                lista.add((FNodoExpresion)t);
                                RESULT = lista; 
                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LISTA_EXP",12, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // LISTA_EXP ::= LISTA_EXP TComa LOGICO 
            {
              Object RESULT =null;
		int listaauxleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int listaauxright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object listaaux = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                                ArrayList<FNodoExpresion> lista = (ArrayList<FNodoExpresion>)listaaux;
                                                                lista.add((FNodoExpresion)exp);
                                                                RESULT = lista;
                                                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LISTA_EXP",12, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // ARREGLO ::= TCorchete_Abre LISTA_EXP TCorchete_Cierra 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int arregloleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int arregloright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object arreglo = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		
                                                                    RESULT = new FNodoExpresion(null, null, Constante.TArreglo, Constante.TArreglo, tleft, tright, new FArreglo((ArrayList<FNodoExpresion>)arreglo));
                                                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("ARREGLO",11, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // METODO_OPERACION_LISTAS ::= TCalcular LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                            ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                            aux.add((FNodoExpresion)exp);
                                                            RESULT = new FLlamadaMetodo(Constante.TCalcular, aux, tleft, tright);
                                                        
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // METODO_OPERACION_LISTAS ::= TMin LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                        ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                        aux.add((FNodoExpresion)exp);
                                                        RESULT = new FLlamadaMetodo(Constante.TMin, aux, tleft, tright);
                                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // METODO_OPERACION_LISTAS ::= TMax LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                        ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                        aux.add((FNodoExpresion)exp);
                                                        RESULT = new FLlamadaMetodo(Constante.TMax, aux, tleft, tright);
                                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // METODO_OPERACION_LISTAS ::= TSucc LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                        ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                        aux.add((FNodoExpresion)exp);
                                                        RESULT = new FLlamadaMetodo(Constante.TSucc, aux, tleft, tright);
                                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // METODO_OPERACION_LISTAS ::= TDecc LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                        ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                        aux.add((FNodoExpresion)exp);
                                                        RESULT = new FLlamadaMetodo(Constante.TDecc, aux, tleft, tright);
                                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // METODO_OPERACION_LISTAS ::= TLength LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                            ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                            aux.add((FNodoExpresion)exp);
                                                            RESULT = new FLlamadaMetodo(Constante.TLength, aux, tleft, tright);
                                                        
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // METODO_OPERACION_LISTAS ::= TDesc LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                        ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                        aux.add((FNodoExpresion)exp);
                                                        RESULT = new FLlamadaMetodo(Constante.TDesc, aux, tleft, tright);
                                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // METODO_OPERACION_LISTAS ::= TAsc LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                        ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                        aux.add((FNodoExpresion)exp);
                                                        RESULT = new FLlamadaMetodo(Constante.TAsc, aux, tleft, tright);
                                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // METODO_OPERACION_LISTAS ::= TPar LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                        ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                        aux.add((FNodoExpresion)exp);
                                                        RESULT = new FLlamadaMetodo(Constante.TPar, aux, tleft, tright);
                                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // METODO_OPERACION_LISTAS ::= TImpr LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                        ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                        aux.add((FNodoExpresion)exp);
                                                        RESULT = new FLlamadaMetodo(Constante.TImpr, aux, tleft, tright);
                                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // METODO_OPERACION_LISTAS ::= TRevers LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                            ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                            aux.add((FNodoExpresion)exp);
                                                            RESULT = new FLlamadaMetodo(Constante.TRevers, aux, tleft, tright);
                                                        
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // METODO_OPERACION_LISTAS ::= TProduct LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                            ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                            aux.add((FNodoExpresion)exp);
                                                            RESULT = new FLlamadaMetodo(Constante.TProduct, aux, tleft, tright);
                                                        
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // METODO_OPERACION_LISTAS ::= TSum LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                    ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                    aux.add((FNodoExpresion)exp);
                                                    RESULT = new FLlamadaMetodo(Constante.TSum, aux, tleft, tright);
                                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_OPERACION_LISTAS",16, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // METODO_CUALQUIERA ::= Id TLlave_Abre TLlave_Cierra 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		
                                                                            RESULT = new FLlamadaMetodo(t.toString(), new ArrayList<FNodoExpresion>(), tleft, tright);
                                                                        
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_CUALQUIERA",21, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // METODO_CUALQUIERA ::= Id TLlave_Abre LISTA_EXP TLlave_Cierra 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object lista = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		
                                                                            RESULT = new FLlamadaMetodo(t.toString(), (ArrayList<FNodoExpresion>)lista, tleft, tright);
                                                                        
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO_CUALQUIERA",21, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // METODO ::= METODO_CUALQUIERA 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 RESULT = t; 
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO",13, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // METODO ::= METODO_OPERACION_LISTAS 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 RESULT = t; 
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("METODO",13, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // LLAMADA_METODO ::= TDolar METODO TDolar 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		 RESULT = t; 
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LLAMADA_METODO",9, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // EXP ::= EXP TIndiceLista EXP 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                    ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                    aux.add((FNodoExpresion)izq);
                                                    aux.add((FNodoExpresion)der);
                                                    FLlamadaMetodo metodo = new FLlamadaMetodo(Constante.TIndiceLista, aux, tleft, tright);
                                                    RESULT = new FNodoExpresion(null, null, Constante.TMetodo, Constante.TMetodo, tleft, tright, metodo);
                                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // EXP ::= EXP TAumento EXP 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                ArrayList<FNodoExpresion> aux = new ArrayList<>();
                                                aux.add((FNodoExpresion)izq);
                                                aux.add((FNodoExpresion)der);
                                                FLlamadaMetodo metodo = new FLlamadaMetodo(Constante.TAumento, aux, tleft, tright);
                                                RESULT = new FNodoExpresion(null, null, Constante.TMetodo, Constante.TMetodo, tleft, tright, metodo);
                                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // EXP ::= Caracter 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                char c = t.toString().charAt(1);                              
                                RESULT = new FNodoExpresion(null, null, Constante.TCaracter, Constante.TCaracter, tleft, tright, c);
                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // EXP ::= ARREGLO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                RESULT =  t;
                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // EXP ::= Cadena 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                            RESULT =  new FNodoExpresion(null, null, Constante.TArreglo, Constante.TArreglo, tleft, tright, new FArreglo(t.toString(), tleft, tright));
                        
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // EXP ::= TParentesis_Abre LOGICO TParentesis_Cierra 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		
                                                                RESULT = t; 
                                                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // EXP ::= LLAMADA_METODO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                    RESULT = new FNodoExpresion(null, null, Constante.TMetodo, Constante.TMetodo, tleft, tright, t); 
                                    
                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // EXP ::= Id 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                        RESULT = new FNodoExpresion(null, null, Constante.TVariable, t.toString(), tleft, tright, null); 
                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // EXP ::= Numero 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                RESULT = new FNodoExpresion(null, null, Constante.TDecimal, Constante.TDecimal, tleft, tright, t); 
                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // EXP ::= TMenos EXP 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                    RESULT = new FNodoExpresion(null, (FNodoExpresion)der, Constante.TMenos, Constante.TMenos, tleft, tright, null); 
                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // EXP ::= EXP TRaiz EXP 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                            RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TRaiz, Constante.TRaiz, tleft, tright, null); 
                                        
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // EXP ::= EXP TPotencia EXP 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                    RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TPotenciaH, Constante.TPotenciaH, tleft, tright, null); 
                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // EXP ::= EXP TModulo EXP 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                    RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TModulo, Constante.TModulo, tleft, tright, null); 
                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // EXP ::= EXP TDivision EXP 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                    RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TDivision, Constante.TDivision, tleft, tright, null); 
                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // EXP ::= EXP TPor EXP 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TPor, Constante.TPor, tleft, tright, null); 
                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // EXP ::= EXP TMenos EXP 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                    RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TMenos, Constante.TMenos, tleft, tright, null);                                    
                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // EXP ::= EXP TMas EXP 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                        RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TMas, Constante.TMas, tleft, tright, null);                                    
                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("EXP",8, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // RELACIONAL ::= EXP 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                RESULT = t;
                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("RELACIONAL",23, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // RELACIONAL ::= RELACIONAL TDiferenciacion RELACIONAL 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                                        RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TDiferenciacion, Constante.TDiferenciacion, tleft, tright, null);
                                                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("RELACIONAL",23, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // RELACIONAL ::= RELACIONAL TIgualacion RELACIONAL 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                                    RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TIgualacion, Constante.TIgualacion, tleft, tright, null);
                                                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("RELACIONAL",23, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // RELACIONAL ::= RELACIONAL TMenorIgual RELACIONAL 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                                    RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TMenorIgual, Constante.TMenorIgual, tleft, tright, null);
                                                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("RELACIONAL",23, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // RELACIONAL ::= RELACIONAL TMayorIgual RELACIONAL 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                                    RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TMayorIgual, Constante.TMayorIgual, tleft, tright, null);
                                                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("RELACIONAL",23, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // RELACIONAL ::= RELACIONAL TMenor RELACIONAL 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                                RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TMenor, Constante.TMenor, tleft, tright, null);
                                                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("RELACIONAL",23, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // RELACIONAL ::= RELACIONAL TMayor RELACIONAL 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                                RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TMayor, Constante.TMayor, tleft, tright, null);
                                                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("RELACIONAL",23, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // LOGICO ::= RELACIONAL 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                RESULT = t;
                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LOGICO",22, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // LOGICO ::= LOGICO TOr LOGICO 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TOr, Constante.TOr, tleft, tright, null);
                                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LOGICO",22, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // LOGICO ::= LOGICO TAnd LOGICO 
            {
              Object RESULT =null;
		int izqleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int izqright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object izq = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int derleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int derright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object der = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                RESULT = new FNodoExpresion((FNodoExpresion)izq, (FNodoExpresion)der, Constante.TAnd, Constante.TAnd, tleft, tright, null);
                                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LOGICO",22, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // VALOR ::= Caracter 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 char c = t.toString().charAt(1); RESULT = new FNodoExpresion(null, null, Constante.TCaracter, Constante.TCaracter, tleft, tright, c); 
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("VALOR",20, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // VALOR ::= Numero 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 RESULT = new FNodoExpresion(null, null, Constante.TDecimal, Constante.TDecimal, tleft, tright, t); 
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("VALOR",20, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // CASO ::= VALOR TDosPuntos CUERPO TPuntoyComa 
            {
              Object RESULT =null;
		int valorleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).right;
		Object valor = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object cuerpo = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		
                                                                    Ambito ambito = new Ambito(Constante.TCase, (ArrayList<Simbolo>)cuerpo, null);
                                                                    FCaso caso = new FCaso((FNodoExpresion)valor, ambito);
                                                                    RESULT = caso;
                                                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("CASO",19, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // LISTA_CASOS ::= CASO 
            {
              Object RESULT =null;
		int casoleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int casoright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object caso = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                    ArrayList<FCaso> lista = new ArrayList<>();
                                    lista.add((FCaso)caso);
                                    RESULT = lista;
                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LISTA_CASOS",18, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // LISTA_CASOS ::= LISTA_CASOS CASO 
            {
              Object RESULT =null;
		int listacleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int listacright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object listac = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int casoleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int casoright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object caso = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                        ArrayList<FCaso> lista = (ArrayList<FCaso>)listac;
                                                        lista.add((FCaso)caso);
                                                        RESULT = lista;
                                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LISTA_CASOS",18, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // SENTENCIA_CASE ::= TCase LOGICO LISTA_CASOS TEnd 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object exp = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int listacleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int listacright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object listac = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		
                                                                    ArrayList<FCaso> lista = (ArrayList<FCaso>)listac;
                                                                    FCase fcase = new FCase((FNodoExpresion)exp, lista, new Ambito(Constante.TCase), null);
                                                                    for(FCaso caso: lista){
                                                                        caso.Padre = fcase.Ambito;
                                                                        for(Simbolo sim: caso.Ambito.TablaSimbolo){
                                                                            sim.Ambito.Padre = fcase.Ambito;
                                                                        }
                                                                    }
                                                                    RESULT = new Simbolo(Constante.TCase, Constante.TCase, Constante.TCase, tleft, tright, fcase.Ambito, fcase);
                                                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("SENTENCIA_CASE",17, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // SENTENCIA_IF ::= TIf LOGICO TThen CUERPO TElse CUERPO TEnd 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-6)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-6)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-6)).value;
		int condleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-5)).left;
		int condright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-5)).right;
		Object cond = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-5)).value;
		int cueleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).left;
		int cueright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).right;
		Object cue = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).value;
		int cue2left = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int cue2right = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object cue2 = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		
                                                                                    ArrayList<Simbolo> si = (ArrayList<Simbolo>)cue;
                                                                                    ArrayList<Simbolo> sino = (ArrayList<Simbolo>)cue2;
                                                                                    Ambito asi = new Ambito(Constante.TIf, si, null);
                                                                                    Ambito asino = new Ambito(Constante.TElse, sino, null);
                                                                                    FIf fsi = new FIf((FNodoExpresion)cond, asi, asino);
                                                                                    for(Simbolo sim: fsi.Ambito.TablaSimbolo){
                                                                                        sim.Ambito.Padre = fsi.Ambito;
                                                                                    }
                                                                                    for(Simbolo sim: fsi.Else.TablaSimbolo){
                                                                                        sim.Ambito.Padre = fsi.Ambito;
                                                                                    }
                                                                                    RESULT = new Simbolo(Constante.TIf, Constante.TIf, Constante.TIf, tleft, tright, fsi.Ambito, fsi);

                                                                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("SENTENCIA_IF",7, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-6)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // DECLARACION_LISTA ::= TLet Id TIgual LOGICO 
            {
              Object RESULT =null;
		int nombreleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int nombreright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object nombre = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object valor = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 RESULT = new Simbolo(Constante.TArreglo, nombre.toString(), Constante.TVariable, nombreleft, nombreright, new Ambito(nombre.toString()), (FNodoExpresion)valor); 
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("DECLARACION_LISTA",10, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // SENTENCIA ::= DECLARACION_LISTA 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 RESULT = t; 
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("SENTENCIA",6, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // SENTENCIA ::= LOGICO 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 
                                        FNodoExpresion nodo = (FNodoExpresion)t;
                                        if(nodo.Tipo == Constante.TMetodo){
                                            FLlamadaMetodo metodo = (FLlamadaMetodo)nodo.Metodo;                                            
                                            RESULT = new Simbolo(Constante.TMetodo, Constante.TMetodo, Constante.TMetodo, tleft, tright, metodo.Ambito, metodo);

                                        }else{
                                            TitusNotificaciones.ImprimirConsola("No se puede llamar una expresion");
                                            nodo.ResolverExpresion();
                                            RESULT = new Simbolo(Constante.TError, Constante.TError, Constante.TError, tleft, tright, new Ambito(Constante.TError), null);
                                        }
                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("SENTENCIA",6, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // SENTENCIA ::= SENTENCIA_CASE 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 RESULT = t; 
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("SENTENCIA",6, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // SENTENCIA ::= SENTENCIA_IF 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 RESULT = t; 
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("SENTENCIA",6, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // LISTA_SENTENCIAS ::= SENTENCIA 
            {
              Object RESULT =null;
		int sentencialeft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int sentenciaright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object sentencia = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                    ArrayList<Simbolo> tabla = new ArrayList<>();
                                                    tabla.add((Simbolo)sentencia);
                                                    RESULT = tabla;
                                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LISTA_SENTENCIAS",5, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // LISTA_SENTENCIAS ::= LISTA_SENTENCIAS SENTENCIA 
            {
              Object RESULT =null;
		int listasentleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int listasentright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object listasent = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int sentencialeft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int sentenciaright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object sentencia = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                                            ArrayList<Simbolo> tabla = (ArrayList<Simbolo>)listasent;
                                                                            tabla.add((Simbolo)sentencia);
                                                                            RESULT = tabla;
                                                                        
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LISTA_SENTENCIAS",5, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // CUERPO ::= LISTA_SENTENCIAS 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 RESULT = t; 
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("CUERPO",4, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // LISTA_PARAMETROS ::= Id 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                    ArrayList<Simbolo> lista = new ArrayList<>();
                                    lista.add(new Simbolo(Constante.TVacio, t.toString(), Constante.TVariable, tleft, tright, new Ambito(t.toString()), null));
                                    RESULT = lista; 
                                
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LISTA_PARAMETROS",3, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // LISTA_PARAMETROS ::= LISTA_PARAMETROS TComa Id 
            {
              Object RESULT =null;
		int listapleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).left;
		int listapright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).right;
		Object listap = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)).value;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		
                                                                ArrayList<Simbolo> lista = (ArrayList<Simbolo>)listap;
                                                                lista.add(new Simbolo(Constante.TVacio, t.toString(), Constante.TVariable, tleft, tright, new Ambito(t.toString()), null));
                                                                RESULT = lista; 
                                                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LISTA_PARAMETROS",3, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-2)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // FUNCION ::= Id TIgual CUERPO TEnd 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object cuerpo = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		 
                                                        ArrayList<Simbolo> simbolo = (ArrayList<Simbolo>)cuerpo;
                                                        Ambito afuncion = new Ambito(t.toString(), simbolo, null);
                                                        FFuncion f = new FFuncion(new ArrayList<Simbolo>(), afuncion);
                                                        for(Simbolo sim: f.Ambito.TablaSimbolo){
                                                            sim.Ambito.Padre = f.Ambito;
                                                        }
                                                        RESULT = new Simbolo(Constante.TMetodo, t.toString(), Constante.TMetodo, tleft, tright, f.Ambito, f);
                                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("FUNCION",2, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // FUNCION ::= Id LISTA_PARAMETROS TIgual CUERPO TEnd 
            {
              Object RESULT =null;
		int tleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-4)).left;
		int tright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-4)).right;
		Object t = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-4)).value;
		int parametrosleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).left;
		int parametrosright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).right;
		Object parametros = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-3)).value;
		int cuerpoleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int cuerporight = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object cuerpo = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		 
                                                                                ArrayList<Simbolo> simbolo = (ArrayList<Simbolo>)cuerpo;
                                                                                Ambito afuncion = new Ambito(t.toString(), simbolo, null);
                                                                                FFuncion f = new FFuncion((ArrayList<Simbolo>)parametros, afuncion);
                                                                                for(Simbolo sim: f.Ambito.TablaSimbolo){
                                                                                    sim.Ambito.Padre = f.Ambito;
                                                                                }
                                                                                RESULT = new Simbolo(Constante.TMetodo, t.toString(), Constante.TMetodo, tleft, tright, f.Ambito, f);
                                                                            
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("FUNCION",2, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-4)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // LISTA_FUNCION ::= FUNCION 
            {
              Object RESULT =null;
		int funcionleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int funcionright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object funcion = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 
                                        ArrayList<Simbolo> lista = new ArrayList<>();
                                        lista.add((Simbolo)funcion);
                                        RESULT = lista;  
                                    
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LISTA_FUNCION",1, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // LISTA_FUNCION ::= LISTA_FUNCION FUNCION 
            {
              Object RESULT =null;
		int listafleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int listafright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object listaf = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		int funcionleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int funcionright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object funcion = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 
                                                            ArrayList<Simbolo> lista = (ArrayList<Simbolo>)listaf;
                                                            lista.add((Simbolo)funcion);
                                                            RESULT = lista;  
                                                        
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("LISTA_FUNCION",1, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // INICIO ::= LISTA_FUNCION 
            {
              Object RESULT =null;
		int funcionleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).left;
		int funcionright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()).right;
		Object funcion = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.peek()).value;
		 
                                            Ambito global = new Ambito("Global", (ArrayList<Simbolo>)funcion, null);
                                            for(Simbolo sim: global.TablaSimbolo){
                                                sim.Ambito.Padre = global;
                                            }
                                            parser.Ejecucion = new Haskell_Ejecucion(global);
                                        
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("INICIO",0, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          return CUP$Haskell_Sintactico$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= INICIO EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)).value;
		RESULT = start_val;
              CUP$Haskell_Sintactico$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.elementAt(CUP$Haskell_Sintactico$top-1)), ((java_cup.runtime.Symbol)CUP$Haskell_Sintactico$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$Haskell_Sintactico$parser.done_parsing();
          return CUP$Haskell_Sintactico$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

